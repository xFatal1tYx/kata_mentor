Как работает HashMap? Метод put? Что происходит при коллизии?

HashMap — основан на хэш-таблицах и реализует интерфейс Map (что подразумевает хранение данных в виде пары ключ/значение).
В основе HashMap лежит массив, элементами которого являются структуры LinkedList.

Пример добавления элемента в HashMap:
1. При использовании метода put, проверяется, если key = null, то элемент добавляется на нулевой индекс.
2. Если key имеет значение, исходя из ключа вычисляется hashcode и определяется index.
3. По данному индексу добавляется bucket (корзина), в который записывается node:
- hashcode
- ссылка на объект
- ссылка на следующий элемент HashMap (null, если его нет)
4. Если в бакете уже содержится node, то новая добавится в конец, а node по этому индексу, будет ссылаться на новую node
5. Если hashcode совпал с одним из элементов (коллизия), а equals вернул false, произойдёт такая же операция
НО если один из элементов будет иметь и одинаковый hashcode, и одинаковый equals, node перезапишется.

Пример получения элемента в HashMap:
1. При использовании метода get, вычисляется hashcode ключа
2. По хешкоду вычисляется индекс элемента
3. Находится бакет по этому индексу и идёт проверка:
hashcode равен? Если нет идём к следующему элементу по ссылке;
Когда hashcode равен, мы сравнием equals, если он не равен, идем к следующему элементу по ссылке;
И только когда равен и hashcode и equals, мы получаем значение элемента

При инициализации HashMap можно указать следующие параметры:
- Initial capacity - начальный размер массива. 
Чем больше размер в начале, тем больше памяти выделится, НО тем быстрее будет происходить поиск.
- Load factor (float) - коэффицент того, насколько массив должен быть заполнен, после чего его размер будет увеличен вдвое
Чем больше Load factor, тем больше памяти будет экономиться, НО тем медленнее будет происходить поиск. 
Золотой серединой принято считать 0.75f 

C JAVA8, при множественных коллизиях, если количество элементов в bucket (кол-во Nodов по одному индексу) достигает большой отметки, 
компилятор начинает использовать сбалансированные деревья (начинает искать элемент по аналогии с binarySearch)
