Явное и неявное приведение типов. В каком случае компилятор не может сделать приведение сам и просит сделать приведение программиста?

Неявные:
Преобразование целочисленных типов происходит безопасно, если количество байт больше или равно исходному типу
Пр. можно преобразовать byte в short, int в long и т.д.

Char можно преобразовать в int и long также без потерь, отрицательные значения будут заполняться нулями в старших битах.

Целочисленные типы можно безопасно преобразовать в вещественные (с плав. точкой), но с потерей точности.

Явные:
При обратных преобразованиях (от большего количества байт к меньшему), необходимо использовать оператор приведения типа и учитывать, что при таком подходе можно потерять информацию.
Пр. byte b = (byte) intValue;
Пр. float f = (float) largeDouble; (может привести к бесконечности)

Если один из операндов имеет тип заданной переменной, то конечный результат автоматически задастся в этом типе.
Пр. double d = 1d + 1f;

НО! Если оба операнда не заданы явно, то в результате вычисления компилятор преобразует их в int, поэтому стоит явно задать преобразование.
Пр. byte a = 1; byte b = 2; byte c = (byte) (a + b); 
При этом запись a += 3; будет автоматически интерпретирована как a = (byte) (a + 3);

Поскольку все операции в Java над целочисленными типами по умолчанию происходят в int, а над вещественными в double, 
при объявлении переменной типа long или float, нам также необходимо явно указать тип.
Пр. long a = 4_000_000_000L; float b = 23.55f;
